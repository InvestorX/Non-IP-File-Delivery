using System;
using NonIPFileDelivery.Models;
using NonIPFileDelivery.Utilities;

namespace NonIPFileDelivery.Services
{
    public class FrameService : IFrameService
    {
        private readonly ILoggingService _logger;
        private readonly ICryptoService _cryptoService;
        private readonly IFragmentationService _fragmentationService;
        private int _sequenceNumber;
        
        // ACK/NACKÁÆ°ÁêÜ
        private readonly System.Collections.Concurrent.ConcurrentDictionary<ushort, DateTime> _pendingAcks;
        private readonly System.Collections.Concurrent.ConcurrentDictionary<ushort, NonIPFrame> _retryQueue;
        private const int ACK_TIMEOUT_MS = 5000; // 5Áßí
        private const int MAX_RETRY_ATTEMPTS = 3;

        // „Ç≥„É≥„Çπ„Éà„É©„ÇØ„Çø
        public FrameService(ILoggingService logger, ICryptoService cryptoService, IFragmentationService fragmentationService)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _cryptoService = cryptoService ?? throw new ArgumentNullException(nameof(cryptoService));
            _fragmentationService = fragmentationService ?? throw new ArgumentNullException(nameof(fragmentationService));
            _sequenceNumber = 0;
            _pendingAcks = new System.Collections.Concurrent.ConcurrentDictionary<ushort, DateTime>();
            _retryQueue = new System.Collections.Concurrent.ConcurrentDictionary<ushort, NonIPFrame>();
        }

        /// <summary>
        /// „Éï„É¨„Éº„É†„Çí„Ç∑„É™„Ç¢„É©„Ç§„Ç∫ÔºàÊöóÂè∑ÂåñÂØæÂøúÔºâ
        /// </summary>
        public byte[] SerializeFrame(NonIPFrame frame)
        {
            if (frame == null)
                throw new ArgumentNullException(nameof(frame));

            try
            {
                // üÜï ÊöóÂè∑Âåñ„Éï„É©„Ç∞„ÅåÁ´ã„Å£„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÄÅPayload„ÇíÊöóÂè∑Âåñ
                if ((frame.Header.Flags & FrameFlags.Encrypted) != 0)
                {
                    _logger.Debug($"Encrypting frame payload ({frame.Payload.Length} bytes)");
                    frame.Payload = _cryptoService.Encrypt(frame.Payload);
                    _logger.Debug($"Encrypted payload size: {frame.Payload.Length} bytes");
                }

                // „Éï„É¨„Éº„É†„ÅÆ„Ç∑„É™„Ç¢„É©„Ç§„Ç∫ÔºàÊó¢Â≠ò„É≠„Ç∏„ÉÉ„ÇØÔºâ
                var headerBytes = SerializeHeader(frame.Header);
                var frameData = new byte[headerBytes.Length + frame.Payload.Length];
                
                Buffer.BlockCopy(headerBytes, 0, frameData, 0, headerBytes.Length);
                Buffer.BlockCopy(frame.Payload, 0, frameData, headerBytes.Length, frame.Payload.Length);

                // CRC32Ë®àÁÆó
                var checksum = Crc32Calculator.Calculate(frameData);
                var result = new byte[frameData.Length + 4];
                
                Buffer.BlockCopy(frameData, 0, result, 0, frameData.Length);
                Buffer.BlockCopy(BitConverter.GetBytes(checksum), 0, result, frameData.Length, 4);

                _logger.Debug($"Frame serialized: {result.Length} bytes (Checksum: 0x{checksum:X8})");
                return result;
            }
            catch (Exception ex)
            {
                _logger.Error($"Frame serialization failed: {ex.Message}", ex);
                throw;
            }
        }

        /// <summary>
        /// „Éï„É¨„Éº„É†„Çí„Éá„Ç∑„É™„Ç¢„É©„Ç§„Ç∫ÔºàÂæ©Âè∑ÂåñÂØæÂøúÔºâ
        /// </summary>
        public NonIPFrame? DeserializeFrame(byte[] data)
        {
            if (data == null || data.Length < 24) // ÊúÄÂ∞è„Éï„É¨„Éº„É†„Çµ„Ç§„Ç∫
                return null;

            try
            {
                // CRC32Ê§úË®ºÔºàÊó¢Â≠ò„É≠„Ç∏„ÉÉ„ÇØÔºâ
                var receivedChecksum = BitConverter.ToUInt32(data, data.Length - 4);
                var frameData = new byte[data.Length - 4];
                Buffer.BlockCopy(data, 0, frameData, 0, frameData.Length);
                var calculatedChecksum = Crc32Calculator.Calculate(frameData);

                if (receivedChecksum != calculatedChecksum)
                {
                    _logger.Warning($"CRC32 mismatch: expected 0x{receivedChecksum:X8}, got 0x{calculatedChecksum:X8}");
                    return null;
                }

                // „Éò„ÉÉ„ÉÄ„ÉºËß£ÊûêÔºàÊó¢Â≠ò„É≠„Ç∏„ÉÉ„ÇØÔºâ
                var header = DeserializeHeader(frameData);
                var payload = new byte[header.PayloadLength];
                Buffer.BlockCopy(frameData, 20, payload, 0, payload.Length); // Ethernet(14) + CustomHeader(6)

                // üÜï ÊöóÂè∑Âåñ„Éï„É©„Ç∞„ÅåÁ´ã„Å£„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÄÅPayload„ÇíÂæ©Âè∑Âåñ
                if ((header.Flags & FrameFlags.Encrypted) != 0)
                {
                    _logger.Debug($"Decrypting frame payload ({payload.Length} bytes)");
                    payload = _cryptoService.Decrypt(payload);
                    _logger.Debug($"Decrypted payload size: {payload.Length} bytes");
                }

                return new NonIPFrame
                {
                    Header = header,
                    Payload = payload,
                    Checksum = receivedChecksum
                };
            }
            catch (Exception ex)
            {
                _logger.Error($"Frame deserialization failed: {ex.Message}", ex);
                return null;
            }
        }

        /// <summary>
        /// „Éè„Éº„Éà„Éì„Éº„Éà„Éï„É¨„Éº„É†„Çí‰ΩúÊàê
        /// </summary>
        public NonIPFrame CreateHeartbeatFrame(byte[] sourceMac)
        {
            if (sourceMac == null || sourceMac.Length != 6)
                throw new ArgumentException("Source MAC address must be 6 bytes", nameof(sourceMac));

            return new NonIPFrame
            {
                Header = new FrameHeader
                {
                    SourceMAC = sourceMac,
                    DestinationMAC = new byte[] { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF }, // Broadcast
                    Type = FrameType.Heartbeat,
                    SequenceNumber = (ushort)System.Threading.Interlocked.Increment(ref _sequenceNumber),
                    PayloadLength = 0,
                    Flags = FrameFlags.None,
                    Timestamp = DateTime.UtcNow
                },
                Payload = Array.Empty<byte>()
            };
        }

        /// <summary>
        /// „Éá„Éº„Çø„Éï„É¨„Éº„É†„Çí‰ΩúÊàê
        /// </summary>
        public NonIPFrame CreateDataFrame(byte[] sourceMac, byte[] destinationMac, byte[] data, FrameFlags flags = FrameFlags.None)
        {
            if (sourceMac == null || sourceMac.Length != 6)
                throw new ArgumentException("Source MAC address must be 6 bytes", nameof(sourceMac));
            if (destinationMac == null || destinationMac.Length != 6)
                throw new ArgumentException("Destination MAC address must be 6 bytes", nameof(destinationMac));
            if (data == null)
                throw new ArgumentNullException(nameof(data));

            return new NonIPFrame
            {
                Header = new FrameHeader
                {
                    SourceMAC = sourceMac,
                    DestinationMAC = destinationMac,
                    Type = FrameType.Data,
                    SequenceNumber = (ushort)System.Threading.Interlocked.Increment(ref _sequenceNumber),
                    PayloadLength = (ushort)data.Length,
                    Flags = flags,
                    Timestamp = DateTime.UtcNow
                },
                Payload = data
            };
        }

        /// <summary>
        /// „Éï„Ç°„Ç§„É´Ëª¢ÈÄÅ„Éï„É¨„Éº„É†„Çí‰ΩúÊàê
        /// </summary>
        public NonIPFrame CreateFileTransferFrame(byte[] sourceMac, byte[] destinationMac, FileTransferFrame fileData)
        {
            if (sourceMac == null || sourceMac.Length != 6)
                throw new ArgumentException("Source MAC address must be 6 bytes", nameof(sourceMac));
            if (destinationMac == null || destinationMac.Length != 6)
                throw new ArgumentException("Destination MAC address must be 6 bytes", nameof(destinationMac));
            if (fileData == null)
                throw new ArgumentNullException(nameof(fileData));

            // FileTransferFrame „Çí„Éê„Ç§„ÉàÈÖçÂàó„Å´„Ç∑„É™„Ç¢„É©„Ç§„Ç∫ÔºàÁ∞°ÊòìÂÆüË£ÖÔºâ
            using var ms = new System.IO.MemoryStream();
            using var writer = new System.IO.BinaryWriter(ms);
            
            writer.Write((byte)fileData.Operation);
            writer.Write(fileData.FileName ?? string.Empty);
            writer.Write(fileData.FileSize);
            writer.Write(fileData.ChunkIndex);
            writer.Write(fileData.TotalChunks);
            writer.Write(fileData.ChunkData?.Length ?? 0);
            if (fileData.ChunkData != null && fileData.ChunkData.Length > 0)
            {
                writer.Write(fileData.ChunkData);
            }
            writer.Write(fileData.FileHash ?? string.Empty);
            writer.Write(fileData.SessionId.ToByteArray());
            
            var payload = ms.ToArray();

            return new NonIPFrame
            {
                Header = new FrameHeader
                {
                    SourceMAC = sourceMac,
                    DestinationMAC = destinationMac,
                    Type = FrameType.FileTransfer,
                    SequenceNumber = (ushort)System.Threading.Interlocked.Increment(ref _sequenceNumber),
                    PayloadLength = (ushort)payload.Length,
                    Flags = FrameFlags.None,
                    SessionId = fileData.SessionId,
                    Timestamp = DateTime.UtcNow
                },
                Payload = payload
            };
        }

        /// <summary>
        /// „Éï„É¨„Éº„É†„ÇíÊ§úË®º
        /// </summary>
        public bool ValidateFrame(NonIPFrame frame, byte[] rawData)
        {
            if (frame == null || rawData == null)
                return false;

            try
            {
                // CRC32„ÉÅ„Çß„ÉÉ„ÇØ„Çµ„É†„ÅÆÊ§úË®º
                var dataWithoutChecksum = new byte[rawData.Length - 4];
                Buffer.BlockCopy(rawData, 0, dataWithoutChecksum, 0, dataWithoutChecksum.Length);
                
                var calculatedChecksum = Crc32Calculator.Calculate(dataWithoutChecksum);
                
                return calculatedChecksum == frame.Checksum;
            }
            catch (Exception ex)
            {
                _logger.Error($"Frame validation error: {ex.Message}", ex);
                return false;
            }
        }

        /// <summary>
        /// „ÉÅ„Çß„ÉÉ„ÇØ„Çµ„É†„ÇíË®àÁÆó
        /// </summary>
        public uint CalculateChecksum(byte[] data)
        {
            return Crc32Calculator.Calculate(data);
        }

        /// <summary>
        /// ACK„Éï„É¨„Éº„É†„Çí‰ΩúÊàê
        /// </summary>
        public NonIPFrame CreateAckFrame(byte[] sourceMac, byte[] destinationMac, ushort sequenceNumber)
        {
            if (sourceMac == null || sourceMac.Length != 6)
                throw new ArgumentException("Source MAC address must be 6 bytes", nameof(sourceMac));
            if (destinationMac == null || destinationMac.Length != 6)
                throw new ArgumentException("Destination MAC address must be 6 bytes", nameof(destinationMac));

            // ACK„Éö„Ç§„É≠„Éº„ÉâÔºàÂèó‰ø°Á¢∫Ë™ç„Åó„Åü„Ç∑„Éº„Ç±„É≥„ÇπÁï™Âè∑Ôºâ
            var payload = BitConverter.GetBytes(sequenceNumber);

            var frame = new NonIPFrame
            {
                Header = new FrameHeader
                {
                    SourceMAC = sourceMac,
                    DestinationMAC = destinationMac,
                    Type = FrameType.Ack,
                    SequenceNumber = (ushort)System.Threading.Interlocked.Increment(ref _sequenceNumber),
                    PayloadLength = (ushort)payload.Length,
                    Flags = FrameFlags.None,
                    Timestamp = DateTime.UtcNow
                },
                Payload = payload
            };

            _logger.Debug($"Created ACK frame for sequence {sequenceNumber}");
            return frame;
        }

        /// <summary>
        /// NACK„Éï„É¨„Éº„É†„Çí‰ΩúÊàêÔºàÂÜçÈÄÅË¶ÅÊ±ÇÔºâ
        /// </summary>
        public NonIPFrame CreateNackFrame(byte[] sourceMac, byte[] destinationMac, ushort sequenceNumber, string reason = "")
        {
            if (sourceMac == null || sourceMac.Length != 6)
                throw new ArgumentException("Source MAC address must be 6 bytes", nameof(sourceMac));
            if (destinationMac == null || destinationMac.Length != 6)
                throw new ArgumentException("Destination MAC address must be 6 bytes", nameof(destinationMac));

            // NACK„Éö„Ç§„É≠„Éº„ÉâÔºàÂÜçÈÄÅË¶ÅÊ±Ç„Åô„Çã„Ç∑„Éº„Ç±„É≥„ÇπÁï™Âè∑ + ÁêÜÁî±Ôºâ
            using var ms = new System.IO.MemoryStream();
            using var writer = new System.IO.BinaryWriter(ms);
            writer.Write(sequenceNumber);
            writer.Write(reason ?? string.Empty);
            var payload = ms.ToArray();

            var frame = new NonIPFrame
            {
                Header = new FrameHeader
                {
                    SourceMAC = sourceMac,
                    DestinationMAC = destinationMac,
                    Type = FrameType.Nack,
                    SequenceNumber = (ushort)System.Threading.Interlocked.Increment(ref _sequenceNumber),
                    PayloadLength = (ushort)payload.Length,
                    Flags = FrameFlags.None,
                    Timestamp = DateTime.UtcNow
                },
                Payload = payload
            };

            _logger.Warning($"Created NACK frame for sequence {sequenceNumber}: {reason}");
            return frame;
        }

        /// <summary>
        /// Â§ß„Åç„Å™„Éö„Ç§„É≠„Éº„Éâ„Çí„Éï„É©„Ç∞„É°„É≥„ÉàÂåñ„Åó„Å¶ÈÄÅ‰ø°Áî®„Éï„É¨„Éº„É†‰ΩúÊàê
        /// </summary>
        public async System.Threading.Tasks.Task<System.Collections.Generic.List<NonIPFrame>> CreateFragmentedFramesAsync(
            byte[] sourceMac, 
            byte[] destinationMac, 
            byte[] data, 
            int maxFragmentSize = 8000,
            FrameFlags additionalFlags = FrameFlags.None)
        {
            if (sourceMac == null || sourceMac.Length != 6)
                throw new ArgumentException("Source MAC address must be 6 bytes", nameof(sourceMac));
            if (destinationMac == null || destinationMac.Length != 6)
                throw new ArgumentException("Destination MAC address must be 6 bytes", nameof(destinationMac));
            if (data == null || data.Length == 0)
                throw new ArgumentException("Data cannot be null or empty", nameof(data));

            _logger.Info($"Creating fragmented frames: DataSize={data.Length}, MaxFragmentSize={maxFragmentSize}");

            // FragmentationService„Çí‰ΩøÁî®„Åó„Å¶„Éï„É©„Ç∞„É°„É≥„ÉàÂåñ
            var fragments = await _fragmentationService.FragmentPayloadAsync(data, maxFragmentSize);

            // MAC „Ç¢„Éâ„É¨„Çπ„ÇíË®≠ÂÆö
            foreach (var frame in fragments)
            {
                frame.Header.SourceMAC = sourceMac;
                frame.Header.DestinationMAC = destinationMac;
                frame.Header.Flags |= additionalFlags; // ËøΩÂä†„Éï„É©„Ç∞„Çí„Éû„Éº„Ç∏
            }

            _logger.Info($"Created {fragments.Count} fragmented frames");
            return fragments;
        }

        /// <summary>
        /// „Éï„É©„Ç∞„É°„É≥„Éà„ÇíËøΩÂä†„Åó„Å¶ÂÜçÊßãÁØâ„ÇíË©¶Ë°å
        /// </summary>
        public async System.Threading.Tasks.Task<byte[]?> AddFragmentAndReassembleAsync(NonIPFrame fragmentFrame)
        {
            if (fragmentFrame == null)
                return null;

            try
            {
                _logger.Debug($"Adding fragment: Seq={fragmentFrame.Header.SequenceNumber}, GroupId={fragmentFrame.Header.FragmentInfo?.FragmentGroupId}");
                
                var result = await _fragmentationService.AddFragmentAsync(fragmentFrame);
                
                if (result != null)
                {
                    _logger.Info($"Fragment reassembly complete: GroupId={result.FragmentGroupId}, Size={result.ReassembledPayload.Length} bytes");
                    return result.ReassembledPayload;
                }
                
                return null;
            }
            catch (Exception ex)
            {
                _logger.Error($"Fragment reassembly failed: {ex.Message}", ex);
                return null;
            }
        }

        /// <summary>
        /// „Éï„É©„Ç∞„É°„É≥„ÉàÂèó‰ø°ÈÄ≤Êçó„ÇíÂèñÂæó
        /// </summary>
        public async System.Threading.Tasks.Task<double?> GetFragmentProgressAsync(Guid fragmentGroupId)
        {
            return await _fragmentationService.GetFragmentProgressAsync(fragmentGroupId);
        }

        /// <summary>
        /// ACKÂæÖÊ©ü‰∏≠„ÅÆ„Éï„É¨„Éº„É†„ÇíËøΩÂä†
        /// </summary>
        public void RegisterPendingAck(NonIPFrame frame)
        {
            if (frame == null) return;

            var sequenceNumber = frame.Header.SequenceNumber;
            _pendingAcks[sequenceNumber] = DateTime.UtcNow;
            _retryQueue[sequenceNumber] = frame;

            _logger.Debug($"Registered pending ACK for sequence {sequenceNumber}");
        }

        /// <summary>
        /// ACKÂèó‰ø°„ÇíÂá¶ÁêÜ
        /// </summary>
        public bool ProcessAck(ushort sequenceNumber)
        {
            if (_pendingAcks.TryRemove(sequenceNumber, out _))
            {
                _retryQueue.TryRemove(sequenceNumber, out _);
                _logger.Debug($"Processed ACK for sequence {sequenceNumber}");
                return true;
            }

            _logger.Warning($"Received ACK for unknown sequence {sequenceNumber}");
            return false;
        }

        /// <summary>
        /// „Çø„Ç§„É†„Ç¢„Ç¶„Éà„Åó„Åü„Éï„É¨„Éº„É†„ÇíÂèñÂæóÔºàÂÜçÈÄÅÁî®Ôºâ
        /// </summary>
        public System.Collections.Generic.List<NonIPFrame> GetTimedOutFrames()
        {
            var timedOutFrames = new System.Collections.Generic.List<NonIPFrame>();
            var now = DateTime.UtcNow;

            foreach (var kvp in _pendingAcks)
            {
                var sequenceNumber = kvp.Key;
                var sentTime = kvp.Value;

                if ((now - sentTime).TotalMilliseconds > ACK_TIMEOUT_MS)
                {
                    if (_retryQueue.TryGetValue(sequenceNumber, out var frame))
                    {
                        timedOutFrames.Add(frame);
                        _logger.Warning($"Frame sequence {sequenceNumber} timed out, adding to retry queue");
                    }

                    // „Çø„Ç§„É†„Ç¢„Ç¶„Éà„Ç®„É≥„Éà„É™„ÇíÂâäÈô§
                    _pendingAcks.TryRemove(sequenceNumber, out _);
                }
            }

            return timedOutFrames;
        }

        /// <summary>
        /// ÂÜçÈÄÅ„Ç≠„É•„Éº„Çí„ÇØ„É™„Ç¢
        /// </summary>
        public void ClearRetryQueue()
        {
            _pendingAcks.Clear();
            _retryQueue.Clear();
            _logger.Info("Retry queue cleared");
        }

        /// <summary>
        /// Áµ±Ë®àÊÉÖÂ†±„ÇíÂèñÂæó
        /// </summary>
        public (int PendingAcks, int RetryQueueSize) GetStatistics()
        {
            return (_pendingAcks.Count, _retryQueue.Count);
        }

        private byte[] SerializeHeader(FrameHeader header)
        {
            using var ms = new System.IO.MemoryStream();
            using var writer = new System.IO.BinaryWriter(ms);
            
            // Ethernet Header
            writer.Write(header.DestinationMAC);
            writer.Write(header.SourceMAC);
            writer.Write(header.EtherType);
            
            // Custom Header
            writer.Write((byte)header.Type);
            writer.Write(header.SequenceNumber);
            writer.Write(header.PayloadLength);
            writer.Write((byte)header.Flags);
            
            return ms.ToArray();
        }

        private FrameHeader DeserializeHeader(byte[] data)
        {
            using var ms = new System.IO.MemoryStream(data);
            using var reader = new System.IO.BinaryReader(ms);
            
            var header = new FrameHeader
            {
                DestinationMAC = reader.ReadBytes(6),
                SourceMAC = reader.ReadBytes(6),
                EtherType = reader.ReadUInt16(),
                Type = (FrameType)reader.ReadByte(),
                SequenceNumber = reader.ReadUInt16(),
                PayloadLength = reader.ReadUInt16(),
                Flags = (FrameFlags)reader.ReadByte()
            };
            
            return header;
        }
    }
}
